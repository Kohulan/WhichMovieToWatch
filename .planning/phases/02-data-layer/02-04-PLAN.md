---
phase: 02-data-layer
plan: 04
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/services/tmdb/client.ts
  - src/services/tmdb/discover.ts
  - src/services/tmdb/details.ts
  - src/services/tmdb/search.ts
  - src/services/tmdb/trending.ts
  - src/services/tmdb/providers.ts
  - src/services/omdb/client.ts
  - src/services/ipinfo/client.ts
autonomous: true
requirements:
  - DISC-05
  - DISC-06

must_haves:
  truths:
    - "TMDB client fetches data with API key from import.meta.env.VITE_TMDB_API_KEY and retries 3 times with exponential backoff on 429/network errors"
    - "Discover service finds random movies with progressive filter relaxation (5 steps) before giving up"
    - "Movie details service fetches full details with credits, videos, and watch/providers in a single append_to_response call"
    - "Search service queries TMDB with pagination support"
    - "Trending service fetches now-playing and popular movies for a region"
    - "Provider service fetches available streaming providers for a region from TMDB"
    - "OMDB client fetches IMDb/Rotten Tomatoes ratings by IMDB ID with daily quota awareness"
    - "IPInfo client detects user country code, defaults to DE on failure"
  artifacts:
    - path: "src/services/tmdb/client.ts"
      provides: "Base TMDB HTTP client with retry and rate limit handling"
      exports: ["tmdbFetch"]
    - path: "src/services/tmdb/discover.ts"
      provides: "Movie discovery with filter relaxation"
      exports: ["discoverMovie"]
    - path: "src/services/tmdb/details.ts"
      provides: "Movie details with appended data"
      exports: ["fetchMovieDetails"]
    - path: "src/services/tmdb/search.ts"
      provides: "Movie search by query"
      exports: ["searchMovies"]
    - path: "src/services/tmdb/trending.ts"
      provides: "Now playing and popular movie lists"
      exports: ["fetchNowPlaying", "fetchPopular"]
    - path: "src/services/tmdb/providers.ts"
      provides: "Streaming provider list per region"
      exports: ["fetchRegionProviders", "fetchMovieProviders"]
    - path: "src/services/omdb/client.ts"
      provides: "OMDB ratings lookup by IMDB ID"
      exports: ["fetchOmdbRatings"]
    - path: "src/services/ipinfo/client.ts"
      provides: "IP geolocation country detection"
      exports: ["detectCountry"]
  key_links:
    - from: "src/services/tmdb/discover.ts"
      to: "src/services/tmdb/client.ts"
      via: "tmdbFetch import"
      pattern: "import.*tmdbFetch.*from.*client"
    - from: "src/services/tmdb/discover.ts"
      to: "src/services/cache/cache-manager.ts"
      via: "getCached/setCache for SWR"
      pattern: "import.*getCached|setCache.*from.*cache"
    - from: "src/services/omdb/client.ts"
      to: "src/services/cache/cache-manager.ts"
      via: "getCached/setCache with OMDB_RATINGS TTL"
      pattern: "TTL\\.OMDB_RATINGS"
    - from: "src/services/ipinfo/client.ts"
      to: "src/types/region.ts"
      via: "IPInfoResponse type"
      pattern: "IPInfoResponse"
---

<objective>
Build all API service clients for TMDB (6 modules), OMDB (1 module), and IPInfo (1 module) with caching, retry logic, and filter relaxation.

Purpose: Services are the data access layer between external APIs and the React hooks. They handle HTTP communication, error mapping, rate limit backoff, and cache integration. The discover service implements smart filter relaxation per user decision (3 network retries + 5 progressive relaxation steps). Services are pure async functions with no React dependency.

Output: 8 service files across src/services/tmdb/, src/services/omdb/, src/services/ipinfo/.
</objective>

<execution_context>
@/Users/kohulanrajan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kohulanrajan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-layer/02-RESEARCH.md
@.planning/phases/02-data-layer/02-01-SUMMARY.md
@src/vite-env.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TMDB API client and endpoint services</name>
  <files>
    src/services/tmdb/client.ts
    src/services/tmdb/discover.ts
    src/services/tmdb/details.ts
    src/services/tmdb/search.ts
    src/services/tmdb/trending.ts
    src/services/tmdb/providers.ts
  </files>
  <action>
1. Create `src/services/tmdb/client.ts`:
   - TMDB_BASE_URL = 'https://api.themoviedb.org/3'
   - TMDB_IMAGE_BASE = 'https://image.tmdb.org/t/p' (for poster/backdrop URLs)
   - Export `tmdbFetch<T>(path: string, params?: Record<string, string | number | boolean>, retries = 3): Promise<T>`:
     - Read API key from `import.meta.env.VITE_TMDB_API_KEY`
     - Construct URL with api_key and params as search params
     - Loop with retry count:
       - On 429: exponential backoff Math.min(2^attempt * 1000, 30000)ms, continue
       - On non-ok response: parse error body, throw Error with `TMDB ${status}: ${message}`
       - On network error (catch): if not last attempt, delay 1000*(attempt+1)ms, continue; else throw
     - Return parsed JSON as T
   - Export `getPosterUrl(path: string | null, size: 'w185' | 'w342' | 'w500' | 'w780' | 'original' = 'w500'): string | null`:
     - If path is null, return null
     - Return `${TMDB_IMAGE_BASE}/${size}${path}`
   - Export `getBackdropUrl(path: string | null, size: 'w300' | 'w780' | 'w1280' | 'original' = 'w1280'): string | null`:
     - Same pattern as getPosterUrl

2. Create `src/services/tmdb/discover.ts`:
   - Import tmdbFetch from ./client, getCached/setCache/TTL from @/services/cache/cache-manager
   - Import TMDBDiscoverResponse, TMDBMovie from @/types/movie
   - Define `DiscoverFilters` interface: genreId (string|null), providerId (number|null), minRating (number), minVoteCount (number), region (string)
   - Define RELAXATION_STEPS array (5 steps per research doc):
     Step 0: {} (original filters)
     Step 1: { minRating: 5.5, minVoteCount: 200 }
     Step 2: { genreId: null } (remove genre)
     Step 3: { minRating: 5.0, minVoteCount: 50 }
     Step 4: { providerId: null } (remove provider)
   - Export `discoverMovie(filters: DiscoverFilters, excludeIds: Set<number>, relaxationStep = 0): Promise<{ movie: TMDBMovie | null; relaxationStep: number }>`:
     - Apply RELAXATION_STEPS[relaxationStep] to filters (merge)
     - Build params: sort_by 'popularity.desc', vote_count.gte, vote_average.gte, include_adult 'false', random page (1-20)
     - Conditionally add with_genres and with_watch_providers + watch_region (ALWAYS pair these two per Pitfall 3)
     - Call tmdbFetch with /discover/movie
     - Filter results to exclude movies in excludeIds
     - If available movies found: return random pick + current relaxationStep
     - If no results and relaxationStep < 4: recurse with relaxationStep + 1
     - If exhausted: return { movie: null, relaxationStep }
   - Export the DiscoverFilters type for use in hooks

3. Create `src/services/tmdb/details.ts`:
   - Import tmdbFetch, getCached, setCache, TTL
   - Import TMDBMovieDetails from @/types/movie
   - Export `fetchMovieDetails(movieId: number): Promise<TMDBMovieDetails>`:
     - Cache key: `movie-details-${movieId}`
     - Check cache first via getCached
     - If cached and not stale, return cached value
     - Fetch from `/movie/${movieId}` with `append_to_response: 'watch/providers,credits,videos'`
     - Cache result with TTL.MOVIE_DETAILS
     - Return result
   - Note: This function does NOT implement SWR itself -- that's the hook's job. This is a simple cache-or-fetch.

4. Create `src/services/tmdb/search.ts`:
   - Export `searchMovies(query: string, page = 1): Promise<TMDBDiscoverResponse>`:
     - Cache key: `search-${query.toLowerCase().trim()}-page${page}`
     - Check cache, return if fresh
     - Fetch from /search/movie with query and page params
     - Cache with TTL.SEARCH_RESULTS
     - Return result

5. Create `src/services/tmdb/trending.ts`:
   - Export `fetchNowPlaying(region: string, page = 1): Promise<TMDBDiscoverResponse>`:
     - Cache key: `now-playing-${region}-page${page}`
     - Check cache, return if fresh
     - Fetch from /movie/now_playing with region and page params
     - Cache with TTL.TRENDING
   - Export `fetchPopular(page = 1): Promise<TMDBDiscoverResponse>`:
     - Cache key: `popular-page${page}`
     - Check cache, return if fresh
     - Fetch from /movie/popular with page param
     - Cache with TTL.TRENDING

6. Create `src/services/tmdb/providers.ts`:
   - Export `fetchRegionProviders(region: string): Promise<Array<{ provider_id: number; provider_name: string; logo_path: string; display_priorities: Record<string, number> }>>`:
     - Cache key: `providers-region-${region}`
     - Fetch from /watch/providers/movie with watch_region param
     - Response has { results: Array<provider> }
     - Cache with TTL.PROVIDER_LIST
     - Return results array
   - Export `fetchMovieProviders(movieId: number, region: string): Promise<WatchProviderCountry | null>`:
     - Cache key: `providers-movie-${movieId}-${region}` (includes region per Pitfall 4)
     - Fetch from /movie/${movieId}/watch/providers
     - Extract results[region] from response
     - Cache with TTL.PROVIDER_LIST
     - Return the country-specific provider data or null if not available in that region
   - Export `fetchAvailableRegions(): Promise<Array<{ iso_3166_1: string; english_name: string; native_name: string }>>`:
     - Cache key: 'provider-regions'
     - Fetch from /watch/providers/regions
     - Cache with TTL.PROVIDER_LIST (24h -- regions rarely change)

CRITICAL PATTERNS:
- Every service function follows cache-check -> fetch -> cache-store pattern
- with_watch_providers ALWAYS paired with watch_region (Pitfall 3)
- Provider cache keys ALWAYS include region (Pitfall 4)
- Never mix fetch and IndexedDB operations in same transaction (Pitfall 6) -- this is handled naturally since getCached/setCache manage their own transactions
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with no errors.
Verify all 6 TMDB service files exist: `ls src/services/tmdb/`.
Verify discover.ts has 5 relaxation steps: `grep -c "Step" src/services/tmdb/discover.ts` or grep for RELAXATION_STEPS array.
Verify details.ts uses append_to_response: `grep "append_to_response" src/services/tmdb/details.ts`.
Verify providers.ts includes region in cache keys: `grep "region" src/services/tmdb/providers.ts`.
  </verify>
  <done>
6 TMDB service files compile and export their functions. Discover service has 5-step filter relaxation. Details fetches credits+videos+providers in one call. All services cache responses in IndexedDB with appropriate TTLs. Provider queries always include region.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create OMDB and IPInfo service clients</name>
  <files>
    src/services/omdb/client.ts
    src/services/ipinfo/client.ts
  </files>
  <action>
1. Create `src/services/omdb/client.ts`:
   - OMDB_BASE_URL = 'https://www.omdbapi.com'
   - Import getCached, setCache, TTL from @/services/cache/cache-manager
   - Define `OmdbRatings` type: { imdbRating: string; rottenTomatoes: string | null; metascore: string | null }
   - Export `fetchOmdbRatings(imdbId: string): Promise<OmdbRatings | null>`:
     - If imdbId is falsy or empty, return null
     - Cache key: `omdb-${imdbId}`
     - Check cache first, return if fresh (even if stale -- OMDB has 1000/day limit, stale data is better than burning quota)
     - Actually: return cached value if it exists at all (stale or not) -- OMDB ratings rarely change, and preserving daily quota is critical. Only fetch if NOT in cache.
     - If not cached: fetch from `${OMDB_BASE_URL}?apikey=${import.meta.env.VITE_OMDB_API_KEY}&i=${imdbId}`
     - Parse response: if response.Response === 'False', cache null result (avoid re-fetching) and return null
     - Extract: imdbRating from response.imdbRating, rottenTomatoes from response.Ratings array where Source === 'Rotten Tomatoes', metascore from response.Metascore
     - If imdbRating === 'N/A', set to null
     - Cache result with TTL.OMDB_RATINGS (24h)
     - Return OmdbRatings object
   - IMPORTANT: This client is designed for lazy loading (Pitfall 2). It should only be called for the currently displayed movie, never for lists.

2. Create `src/services/ipinfo/client.ts`:
   - IPINFO_URL = 'https://ipinfo.io/json'
   - Import IPInfoResponse from @/types/region
   - Export `detectCountry(): Promise<string>`:
     - Default country: 'DE'
     - Try fetching from IPINFO_URL (no auth token -- unauthenticated free tier per research)
     - If response.ok: parse JSON as IPInfoResponse, return response.country (2-letter ISO code)
     - If fetch fails or response.country is missing: try fallback via navigator.language
       - navigator.language gives locale like 'de-DE' or 'en-US'
       - Extract country code from after the hyphen, uppercase
       - If no hyphen, return default 'DE'
     - On any error: return default 'DE'
     - This function does NOT cache -- the regionStore handles persistence. This is a one-shot detection.
   - Export the default country as `DEFAULT_COUNTRY = 'DE'` for consumers to reference

Both clients are pure async functions. No React, no Zustand imports.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with no errors.
Verify OMDB client exists: `ls src/services/omdb/client.ts`.
Verify IPInfo client exists: `ls src/services/ipinfo/client.ts`.
Verify OMDB uses cache: `grep "getCached\|setCache" src/services/omdb/client.ts`.
Verify IPInfo defaults to DE: `grep "DE" src/services/ipinfo/client.ts`.
  </verify>
  <done>
OMDB client fetches IMDb/RT/Metascore ratings by IMDB ID with aggressive caching (returns any cached value to conserve 1000/day quota). IPInfo client detects country code with navigator.language fallback and DE default. Both are pure async functions.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. 8 service files exist across tmdb/, omdb/, ipinfo/
3. TMDB client reads API key from import.meta.env.VITE_TMDB_API_KEY
4. Discover service has 5 relaxation steps and excludes shown movies
5. Details uses append_to_response for single-request enrichment
6. OMDB aggressively caches to conserve daily quota
7. IPInfo defaults to DE and uses navigator.language as fallback
8. All provider-related cache keys include region
9. No React imports in any service file
</verification>

<success_criteria>
- TMDB client handles 429 with exponential backoff and retries network errors 3 times
- Discover service relaxes filters progressively (5 steps) when no movies match
- All TMDB services cache responses in IndexedDB with type-appropriate TTLs
- OMDB client conserves 1000/day quota by returning any cached value
- IPInfo client detects region and defaults to DE per DISC-06
- watch_providers always paired with watch_region in TMDB queries
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-layer/02-04-SUMMARY.md`
</output>
