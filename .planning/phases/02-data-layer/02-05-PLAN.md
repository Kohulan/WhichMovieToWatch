---
phase: 02-data-layer
plan: 05
type: execute
wave: 3
depends_on:
  - 02-01
  - 02-02
  - 02-03
  - 02-04
files_modified:
  - src/hooks/useRandomMovie.ts
  - src/hooks/useMovieDetails.ts
  - src/hooks/useOmdbRatings.ts
  - src/hooks/useSearchMovies.ts
  - src/hooks/useTrending.ts
  - src/hooks/useWatchProviders.ts
  - src/hooks/useRegion.ts
autonomous: true
requirements:
  - DISC-05
  - DISC-06

must_haves:
  truths:
    - "useRandomMovie discovers a random movie excluding already-shown IDs and applies taste-weighted selection"
    - "useMovieDetails returns cached movie details immediately and refreshes stale data in background (SWR)"
    - "useOmdbRatings lazily fetches OMDB data only for the currently displayed movie, not for lists"
    - "useSearchMovies searches TMDB with debounce-ready query and pagination"
    - "useTrending returns now-playing movies for the user's region with 30-min auto-refresh"
    - "useWatchProviders returns providers categorized by tier (stream/rent/buy/free/ads) for a movie in the user's region"
    - "useRegion detects country on first use, persists it, and supports manual override with provider cache invalidation"
  artifacts:
    - path: "src/hooks/useRandomMovie.ts"
      provides: "Discovery hook with filter relaxation and taste scoring"
      exports: ["useRandomMovie"]
    - path: "src/hooks/useMovieDetails.ts"
      provides: "SWR movie details hook"
      exports: ["useMovieDetails"]
    - path: "src/hooks/useOmdbRatings.ts"
      provides: "Lazy OMDB ratings hook"
      exports: ["useOmdbRatings"]
    - path: "src/hooks/useSearchMovies.ts"
      provides: "Search with pagination hook"
      exports: ["useSearchMovies"]
    - path: "src/hooks/useTrending.ts"
      provides: "Now playing with auto-refresh hook"
      exports: ["useTrending"]
    - path: "src/hooks/useWatchProviders.ts"
      provides: "Provider tiers for a movie hook"
      exports: ["useWatchProviders"]
    - path: "src/hooks/useRegion.ts"
      provides: "Region detection and override hook"
      exports: ["useRegion"]
  key_links:
    - from: "src/hooks/useRandomMovie.ts"
      to: "src/services/tmdb/discover.ts"
      via: "discoverMovie function call"
      pattern: "import.*discoverMovie.*from.*discover"
    - from: "src/hooks/useRandomMovie.ts"
      to: "src/stores/movieHistoryStore.ts"
      via: "getExcludeSet for repeat prevention"
      pattern: "useMovieHistoryStore"
    - from: "src/hooks/useRandomMovie.ts"
      to: "src/stores/discoveryStore.ts"
      via: "setCurrentMovie, setLoading, setError"
      pattern: "useDiscoveryStore"
    - from: "src/hooks/useRegion.ts"
      to: "src/services/ipinfo/client.ts"
      via: "detectCountry on first use"
      pattern: "import.*detectCountry.*from.*ipinfo"
    - from: "src/hooks/useRegion.ts"
      to: "src/stores/regionStore.ts"
      via: "effectiveRegion, setDetectedCountry, setManualOverride"
      pattern: "useRegionStore"
    - from: "src/hooks/useRegion.ts"
      to: "src/services/cache/cache-manager.ts"
      via: "invalidateByPrefix on region change"
      pattern: "invalidateByPrefix"
    - from: "src/hooks/useOmdbRatings.ts"
      to: "src/services/omdb/client.ts"
      via: "fetchOmdbRatings for lazy enrichment"
      pattern: "import.*fetchOmdbRatings.*from.*omdb"
---

<objective>
Create all React hooks that wire services, stores, and cache into a consumable API for UI components.

Purpose: Hooks are the public API of the data layer. Feature-phase components (Phase 3+) import these hooks to access movie data, search, trending, providers, and region settings. Each hook encapsulates the complexity of caching, state updates, and error handling behind a simple React interface.

Output: 7 React hooks in src/hooks/ that compose services + stores + cache.
</objective>

<execution_context>
@/Users/kohulanrajan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kohulanrajan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-layer/02-RESEARCH.md
@.planning/phases/02-data-layer/02-01-SUMMARY.md
@.planning/phases/02-data-layer/02-02-SUMMARY.md
@.planning/phases/02-data-layer/02-03-SUMMARY.md
@.planning/phases/02-data-layer/02-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create discovery, details, ratings, and search hooks</name>
  <files>
    src/hooks/useRandomMovie.ts
    src/hooks/useMovieDetails.ts
    src/hooks/useOmdbRatings.ts
    src/hooks/useSearchMovies.ts
  </files>
  <action>
1. Create `src/hooks/useRandomMovie.ts`:
   - Import: discoverMovie + DiscoverFilters from @/services/tmdb/discover, useMovieHistoryStore, useDiscoveryStore, usePreferencesStore, scoreTasteMatch from @/lib/taste-engine, fetchMovieDetails from @/services/tmdb/details
   - Export `useRandomMovie()` returning `{ discover, isLoading, error, currentMovie, relaxationStep }`:
     - Read currentMovie, isLoading, error, relaxationStep from useDiscoveryStore
     - `discover` is an async function:
       1. Get excludeIds from useMovieHistoryStore.getState().getExcludeSet()
       2. Get filters from useDiscoveryStore.getState().filters
       3. Get effectiveRegion from useRegionStore (import it)
       4. Set loading true, error null via discoveryStore
       5. Call discoverMovie({ ...filters, region: effectiveRegion }, excludeIds)
       6. If movie found:
          - Fetch full details via fetchMovieDetails(movie.id)
          - Apply taste scoring: get tasteProfile from usePreferencesStore.getState()
          - Score the movie with scoreTasteMatch (informational -- log to console for now, actual sorting in discovery lists is a Phase 3 concern)
          - Track as shown via movieHistoryStore.getState().trackShown(movie.id)
          - Set currentMovie in discoveryStore
       7. If no movie found: set error "No movies found matching your filters. Try different criteria."
       8. Set loading false, update relaxationStep
     - Return all state + discover function
   - Hook uses useCallback for discover to keep reference stable

2. Create `src/hooks/useMovieDetails.ts`:
   - Import: getCached, setCache, TTL from cache-manager, fetchMovieDetails from tmdb/details
   - Import: TMDBMovieDetails from @/types/movie
   - Export `useMovieDetails(movieId: number | null)` returning `{ data, isLoading, error }`:
     - useState for data (TMDBMovieDetails | null), isLoading, error
     - useEffect triggered by movieId:
       - If movieId is null, reset state and return
       - SWR pattern (follow research Pattern 3 exactly):
         1. Check cache for `movie-details-${movieId}`
         2. If cached value exists: setData immediately
         3. If not stale: return (done)
         4. If stale or no cache: fetch fresh (show loading only if no cached data)
         5. On fresh data: setData, setCache
         6. On error: set error only if no cached fallback available
     - Return { data, isLoading, error }

3. Create `src/hooks/useOmdbRatings.ts`:
   - Import: fetchOmdbRatings from @/services/omdb/client
   - Export `useOmdbRatings(imdbId: string | null)` returning `{ imdbRating, rottenTomatoes, metascore, isLoading }`:
     - useState for ratings (OmdbRatings | null) and isLoading
     - useEffect triggered by imdbId:
       - If imdbId is null or empty, return
       - Set isLoading true
       - Call fetchOmdbRatings(imdbId)
       - Set ratings result, isLoading false
       - On error: log warning (don't break UI over missing ratings), set isLoading false
     - Return individual rating fields (destructured from state) + isLoading
   - IMPORTANT: This hook is ONLY called for a single displayed movie, NEVER in a list/loop (Pitfall 2). The component using this hook should render it conditionally.

4. Create `src/hooks/useSearchMovies.ts`:
   - Import: searchMovies from @/services/tmdb/search, useSearchStore
   - Export `useSearchMovies()` returning `{ search, loadMore, query, results, isLoading, error, totalResults, hasMore }`:
     - Read state from useSearchStore
     - `search(query: string)` async function:
       - If query is empty or whitespace, reset store and return
       - Set query in store, set loading true
       - Call searchMovies(query, 1)
       - Set results, totalResults, totalPages, currentPage in store
       - Set loading false
       - On error: set error in store
     - `loadMore()` async function:
       - If currentPage >= totalPages, return
       - Set loading true
       - Call searchMovies(query, currentPage + 1)
       - appendResults in store
       - Set loading false
     - `hasMore`: computed from currentPage < totalPages
     - Return all state + functions
   - Note: Debouncing is a UI concern (Phase 3) -- the hook provides the search function, the component applies debounce.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with no errors.
Verify all 4 hooks exist: `ls src/hooks/useRandomMovie.ts src/hooks/useMovieDetails.ts src/hooks/useOmdbRatings.ts src/hooks/useSearchMovies.ts`.
Verify useRandomMovie imports discoverMovie: `grep "discoverMovie" src/hooks/useRandomMovie.ts`.
Verify useMovieDetails implements SWR: `grep "isStale" src/hooks/useMovieDetails.ts`.
  </verify>
  <done>
4 hooks compile: useRandomMovie discovers with filter relaxation + taste scoring + history tracking, useMovieDetails implements SWR cache pattern, useOmdbRatings lazily fetches ratings, useSearchMovies provides search with pagination.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create trending, providers, and region hooks</name>
  <files>
    src/hooks/useTrending.ts
    src/hooks/useWatchProviders.ts
    src/hooks/useRegion.ts
  </files>
  <action>
1. Create `src/hooks/useTrending.ts`:
   - Import: fetchNowPlaying, fetchPopular from @/services/tmdb/trending, useRegionStore
   - Import TMDBMovie from @/types/movie
   - Export `useTrending()` returning `{ movies, isLoading, error, refresh }`:
     - useState for movies (TMDBMovie[]), isLoading, error
     - Get region from useRegionStore (effectiveRegion)
     - useEffect triggered by region:
       - Fetch now_playing for region, page 1
       - Set movies from results, handle errors
       - Set up 30-minute auto-refresh interval: `setInterval(refresh, 30 * 60 * 1000)`
       - Clear interval on cleanup
     - `refresh` function: re-fetches now_playing (forces network fetch by checking cache staleness)
     - If now_playing returns empty results, fall back to fetchPopular
     - Return { movies, isLoading, error, refresh }

2. Create `src/hooks/useWatchProviders.ts`:
   - Import: fetchMovieProviders, fetchRegionProviders from @/services/tmdb/providers
   - Import: useRegionStore, usePreferencesStore
   - Import: isFreeProvider from @/lib/provider-registry
   - Import: WatchProviderCountry, WatchProvider from @/types/movie
   - Import: MovieProviders, ProviderTier from @/types/provider
   - Export `useWatchProviders(movieId: number | null)` returning `{ providers, isLoading, myProviders, allProviders }`:
     - useState for raw provider data (WatchProviderCountry | null) and isLoading
     - Get region from useRegionStore (effectiveRegion)
     - Get myServices from usePreferencesStore
     - useEffect triggered by movieId + region:
       - If movieId null, return
       - Fetch providers for movieId + region
       - Set raw data
     - Derive `providers: MovieProviders` from raw data:
       - Categorize into tiers: flatrate (stream), rent, buy, free, ads
       - Add tmdb_link from raw data's link field
       - For each provider, add isFree flag via isFreeProvider()
     - Derive `myProviders`: filter all provider lists to only include providers whose ID is in myServices
     - Derive `allProviders`: the full categorized list
     - Return { providers, isLoading, myProviders, allProviders }
   - Export `useRegionProviders()` returning `{ providers, isLoading }`:
     - Fetches the full provider list for the effective region (for settings UI)
     - Uses fetchRegionProviders(region)

3. Create `src/hooks/useRegion.ts`:
   - Import: detectCountry from @/services/ipinfo/client
   - Import: useRegionStore
   - Import: invalidateByPrefix from @/services/cache/cache-manager
   - Export `useRegion()` returning `{ region, detectedCountry, manualOverride, setOverride, isDetecting }`:
     - Read state from useRegionStore
     - useState for isDetecting
     - useEffect on mount (empty deps):
       - Check regionStore.getState().needsDetection()
       - If true: set isDetecting, call detectCountry(), update store with setDetectedCountry, set isDetecting false
     - `region`: effectiveRegion() from store
     - `setOverride(country: string | null)` async function:
       - Set manual override in store
       - Invalidate provider-related caches: `await invalidateByPrefix('providers-')`
       - This ensures stale provider data from old region is cleared (user decision: "Region change invalidates provider cache")
     - Return all state + setOverride function
   - CRITICAL: Region detection runs ONCE on first load (when needsDetection returns true). Subsequent loads use persisted value. Manual override persists across sessions.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with no errors.
Verify all 3 hooks exist: `ls src/hooks/useTrending.ts src/hooks/useWatchProviders.ts src/hooks/useRegion.ts`.
Verify useTrending has auto-refresh: `grep "setInterval\|30.*60.*1000" src/hooks/useTrending.ts`.
Verify useRegion calls detectCountry: `grep "detectCountry" src/hooks/useRegion.ts`.
Verify useRegion invalidates cache on override: `grep "invalidateByPrefix" src/hooks/useRegion.ts`.
  </verify>
  <done>
3 hooks compile: useTrending fetches region-aware now-playing with 30-min auto-refresh, useWatchProviders categorizes providers by tier with free-provider badges, useRegion auto-detects country and invalidates provider cache on manual override.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. 7 new hooks exist in src/hooks/ (plus existing useTheme.ts, useSound.ts, useMigration.ts = 10 total)
3. useRandomMovie uses movieHistoryStore to exclude shown movies (DISC-05)
4. useRandomMovie uses discoveryStore for filter relaxation state
5. useRegion detects country via IPInfo and defaults to DE (DISC-06)
6. useRegion invalidates provider cache on region change
7. useMovieDetails implements SWR (shows cached data immediately, refreshes stale)
8. useOmdbRatings is designed for single-movie use (not lists)
9. useTrending has 30-minute auto-refresh interval
10. useWatchProviders categorizes by tier (flatrate/rent/buy/free/ads)
</verification>

<success_criteria>
- All 7 hooks compile and export their functions
- Discovery hook prevents repeat movies via history store (DISC-05)
- Region hook auto-detects country and defaults to DE (DISC-06)
- SWR pattern implemented in movie details hook
- OMDB ratings lazy-loaded for single movies only
- Trending auto-refreshes every 30 minutes
- Provider cache invalidated on region change
- All hooks compose stores + services + cache without internal side effects beyond state updates
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-layer/02-05-SUMMARY.md`
</output>
