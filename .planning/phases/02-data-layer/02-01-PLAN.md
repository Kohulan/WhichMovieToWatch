---
phase: 02-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/movie.ts
  - src/types/provider.ts
  - src/types/region.ts
  - src/types/preferences.ts
  - src/services/cache/db.ts
  - src/services/cache/cache-manager.ts
  - src/services/cache/types.ts
  - package.json
autonomous: true
requirements:
  - DISC-05
  - DISC-06

must_haves:
  truths:
    - "TypeScript types exist for TMDB movie responses, watch providers with pricing tiers, regions, and user preferences"
    - "IndexedDB database initializes with an api-cache object store and by-cached-at index"
    - "Cache manager can store, retrieve, and check staleness of cached entries using TTL"
    - "Stale entries return their value with isStale=true instead of null"
  artifacts:
    - path: "src/types/movie.ts"
      provides: "TMDBMovie, TMDBMovieDetails, WatchProvider, WatchProviderCountry, EnrichedMovie types"
      contains: "TMDBMovieDetails"
    - path: "src/types/provider.ts"
      provides: "Provider types with pricing tier categorization"
      contains: "ProviderTier"
    - path: "src/types/region.ts"
      provides: "Region types for geolocation and manual override"
      contains: "RegionState"
    - path: "src/types/preferences.ts"
      provides: "TasteProfile and preference types"
      contains: "TasteProfile"
    - path: "src/services/cache/db.ts"
      provides: "IndexedDB connection via idb with typed schema"
      contains: "MovieCacheDB"
    - path: "src/services/cache/cache-manager.ts"
      provides: "TTL-based get/set/evict with SWR staleness check"
      exports: ["getCached", "setCache", "invalidateByPrefix", "TTL"]
  key_links:
    - from: "src/services/cache/cache-manager.ts"
      to: "src/services/cache/db.ts"
      via: "getDB() import"
      pattern: "import.*getDB.*from.*db"
    - from: "src/services/cache/cache-manager.ts"
      to: "src/services/cache/types.ts"
      via: "CacheEntry type import"
      pattern: "import.*CacheEntry.*from.*types"
---

<objective>
Install `idb` dependency, create all shared TypeScript types, and build the IndexedDB cache layer with TTL-based stale-while-revalidate support.

Purpose: Establish the type foundation and caching infrastructure that all API services, stores, and hooks depend on. Types define the contract between TMDB/OMDB responses and the React layer. The cache layer enables offline-first data access with per-entry TTL.

Output: TypeScript type definitions in src/types/, IndexedDB cache service in src/services/cache/, idb added to package.json.
</objective>

<execution_context>
@/Users/kohulanrajan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kohulanrajan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-layer/02-RESEARCH.md
@src/stores/themeStore.ts
@src/vite-env.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install idb and create TypeScript type definitions</name>
  <files>
    package.json
    src/types/movie.ts
    src/types/provider.ts
    src/types/region.ts
    src/types/preferences.ts
  </files>
  <action>
1. Install `idb` v8: `npm install idb`

2. Create `src/types/movie.ts` with these types (follow research doc exactly):
   - `TMDBMovie`: id, title, original_title, overview, poster_path (string|null), backdrop_path (string|null), release_date (string), runtime (number|null), vote_average (number 0-10), vote_count, popularity, genres (Array of {id, name}), genre_ids (number[] optional - present in list responses), original_language, adult
   - `TMDBMovieDetails extends TMDBMovie`: imdb_id (string|null), budget, revenue, tagline, status, production_companies (Array of {id, name, logo_path}), credits (optional: cast Array of {id, name, character, profile_path}, crew Array of {id, name, job, department}), videos (optional: results Array of {key, site, type, name}), `watch/providers` (optional: results Record of string to WatchProviderCountry)
   - `WatchProviderCountry`: link (string), flatrate/rent/buy/free/ads (all optional WatchProvider[])
   - `WatchProvider`: provider_id, provider_name, logo_path, display_priority
   - `EnrichedMovie extends TMDBMovieDetails`: omdb (optional: {imdbRating: string, rottenTomatoes: string, metascore: string})
   - `TMDBDiscoverResponse`: page, total_pages, total_results, results (TMDBMovie[])
   - `TMDBSearchResponse`: same shape as TMDBDiscoverResponse

3. Create `src/types/provider.ts`:
   - `ProviderTier`: union type of 'flatrate' | 'rent' | 'buy' | 'free' | 'ads'
   - `ProviderInfo`: provider_id, provider_name, logo_path, display_priority, deep_link (string|null)
   - `MovieProviders`: Record of ProviderTier to ProviderInfo[] (all optional), plus tmdb_link (string)
   - `RegionProvider`: provider_id, provider_name, logo_path, display_priorities (Record of string to number)

4. Create `src/types/region.ts`:
   - `RegionInfo`: countryCode (string), countryName (string), detectedAt (number timestamp)
   - `IPInfoResponse`: ip, city, region, country (2-letter ISO), loc, org, timezone

5. Create `src/types/preferences.ts`:
   - `TasteProfile`: genres (Record of number to number for genreId->weight), decades (Record of string to number), directors (Record of number to number), lastUpdated (number timestamp)
   - `TasteSignal`: 'love' | 'not-interested'
   - `MovieInteraction`: movieId (number), signal (TasteSignal), genres (number[]), decade (string), directorId (number|undefined), timestamp (number)

All types should use `export interface` or `export type`. No runtime code in type files.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with no type errors.
Verify `idb` appears in package.json dependencies.
Verify all 4 type files exist with `ls src/types/`.
  </verify>
  <done>
All 4 type files exist, export the specified interfaces/types, and compile without errors. `idb` is in package.json.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build IndexedDB cache layer with TTL and SWR</name>
  <files>
    src/services/cache/types.ts
    src/services/cache/db.ts
    src/services/cache/cache-manager.ts
  </files>
  <action>
1. Create `src/services/cache/types.ts`:
   - `CacheEntry<T = unknown>`: key (string), value (T), cachedAt (number - Date.now()), ttl (number - milliseconds)

2. Create `src/services/cache/db.ts`:
   - Import `openDB` and `DBSchema` from `idb`
   - Define `MovieCacheDB extends DBSchema` with one object store 'api-cache': key is string, value is CacheEntry, indexes: 'by-cached-at' on cachedAt field
   - DB_NAME = 'wmtw-cache', DB_VERSION = 1
   - Export `getDB()` function that calls `openDB<MovieCacheDB>()` with upgrade handler creating the object store and index
   - Use a module-level promise variable to cache the DB connection (singleton pattern -- don't open multiple connections)

3. Create `src/services/cache/cache-manager.ts`:
   - Import `getDB` from `./db` and `CacheEntry` from `./types`
   - Export `TTL` const object with: TRENDING = 30*60*1000 (30min), MOVIE_DETAILS = 24*60*60*1000 (24h), SEARCH_RESULTS = 60*60*1000 (1h), PROVIDER_LIST = 24*60*60*1000 (24h), OMDB_RATINGS = 24*60*60*1000 (24h)
   - Export `getCached<T>(key: string): Promise<{ value: T | null; isStale: boolean }>`:
     - Get entry from 'api-cache' store by key
     - If not found, return { value: null, isStale: true }
     - Calculate age = Date.now() - entry.cachedAt, isStale = age > entry.ttl
     - Return { value: entry.value as T, isStale }
   - Export `setCache<T>(key: string, value: T, ttlMs: number): Promise<void>`:
     - Put entry into 'api-cache' store with key, value, cachedAt: Date.now(), ttl: ttlMs
   - Export `invalidateByPrefix(prefix: string): Promise<void>`:
     - Open a cursor on 'api-cache', iterate all entries, delete those whose key starts with prefix
     - This supports region-change invalidation (delete all keys starting with 'providers-')
   - Export `evictExpired(): Promise<number>`:
     - Iterate all entries, delete those where Date.now() - cachedAt > ttl
     - Return count of evicted entries
     - Used for periodic cleanup (not called automatically -- hooks can call on app start)

IMPORTANT: Never mix fetch calls inside IndexedDB transactions (Pitfall 6 from research). Each function opens its own short transaction.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with no type errors.
Verify all 3 cache files exist with `ls src/services/cache/`.
Verify exports: `grep -r "export" src/services/cache/cache-manager.ts` shows getCached, setCache, invalidateByPrefix, evictExpired, TTL.
  </verify>
  <done>
Cache layer compiles, exports getCached/setCache/invalidateByPrefix/evictExpired/TTL, uses idb for IndexedDB access with typed schema, and implements TTL-based staleness checks for SWR pattern.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm ls idb` shows idb installed
3. All type files exist: movie.ts, provider.ts, region.ts, preferences.ts
4. All cache files exist: db.ts, cache-manager.ts, types.ts
5. Cache manager exports TTL constants matching research spec (30min, 24h, 1h)
</verification>

<success_criteria>
- idb v8 is installed and in package.json
- 4 type definition files compile and export all specified interfaces
- IndexedDB cache layer opens a typed database with api-cache store
- Cache manager provides get/set/invalidate/evict operations with TTL-based SWR
- No runtime code in type files; cache layer is pure async (no React)
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-layer/02-01-SUMMARY.md`
</output>
